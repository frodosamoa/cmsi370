\documentclass[11pt, oneside]{article}   
\usepackage{geometry}                	
\geometry{letterpaper}                   	
\usepackage{graphicx}		
\usepackage{amssymb}
\usepackage{applekeys}
\usepackage[T1]{fontenc}
\usepackage{menukeys}
\usepackage{enumitem}
\usepackage{chngpage}
\usepackage{multirow}


\title{Dream Design of a Text Editor}
\author{Andrew Kowalczyk}
\date{December 06, 2013}						

\begin{document}
\maketitle


\section{Design}

Text editors are some of the most important pieces of software that programmers can use for their craft. I think a redesign of this application using multiple interaction styles would be incredibly beneficial for a coder/programmer. For this particular assignment, I will model the way this application/package/plugin would work by emulating \textbf{Sublime Text 2} and \textbf{3}'s menus and actions.

The design would mainly use audio recording from the user for all main actions. When the user simply gets tired of typing, they can revert to their spoken voice for accomplishing their goal. The ability to type in the editor is always a possibility and can be relied upon in the event of the audio recording not working as planned.

Certain key combinations would denote certain types of actions. Whenever a user will hold the key combination, the application would wait for some kind of input and only after the user lets go of the keys will the application respond. This application would be advanced enough to be able to read and recognize variable and function names given by the user. The reason for choosing different key combinations for user input is because attempting to have the application attempt to decode what a user is trying to say is extremely hard. This way the application would know what kind of input it would be receiving.

When the user would launch the application for the first time, they would be guided through a series of tasks for them to be acquainted with the overall commands of the application. This would be comprehensive enough for them to be able to code from the get go.

Also, this application could be modified to simply be an extension for any text editor \textit{TextWrangler}, \textit{Notepad++}, or \textit{MacVim}. This way, cross application compatibility would be functional.

\section{\menu{File} actions}

\keys{\Alt + Y}
Complete a specific file action. Input ranges from: "save", "save as", "save all", "new file", "close file", "close all files", "open most recent", "open last closed file", "close window", and "new window". Each respective action does what it denotes.

\section{\menu{Edit}}

	\subsection{\menu{Edit} actions}
	\keys{\Alt + E}
	Completes a specific edit action. Input ranges from: "cut", "copy", "paste", and "paste and indent". Each respective action does what it denotes.

	\subsection{Undo and repeat}
	\keys{\Alt + Z}
	Undoes or repeats an action. Input can be: "undo" or "repeat".


\section{\menu{Selection}}

	\subsection{\menu{Selection} actions}
	\keys{\Alt + S}
	Selects a certain part of the text. Voice input can include: "all", "word", "line", "paragraph", "scope", "indentation", and "brackets". Any of the previous commands except for "all" can be prefixed with "end of" or "beginning of" to select from the cursor to the beginning or end of the word, line, paragraph, etc. Also, input can include: "right" and "left" to move the cursor one character over in either direction.

	\subsection{Selection manipulation}
	\keys{\Alt + S + M}
	Manipulates the selection in several ways. Input includes: "duplicate", "comment", "uncomment", "indent", "insert line". "indent" can be suffixed with "left" or "right". "insert line" can be suffixed with "before" and "after". If the user has selected multiple subsequent lines, another input can be "join". This joins the selection on to one line. 

	\subsection{Moving text}
	\keys{\Alt + M}
	Moves the text. Input that the user can provide: "up", "down", "bottom", and "top". "up" and "down" can be suffixed with any number followed by "line" or "lines". For example, "up one line" or "down seventeen lines".

	\subsection{Case conversion and text styles}
	\keys{\Alt + T}
	Changes the style of a selection. Sample input includes: "upper case" and "lower case". If a user is preparing a document using \LaTeX, some more input could be: "bold", "italic", "underlined", etc. This would allow them to change specific style of text in that document preparation system. Depending on what type of packages a user is using more commands could be defined for ease of use.

\section{\menu{Find}}

	\subsection{Find}
	\keys{\Alt + F}
	Finds a word or phrase. Input is whatever the user wants to search for.

	\subsection{Find similar selections}
	\keys{\Alt + F + S}
	Finds next, previous, or all similar selections. Input ranges from: "next", "previous", and "all". This command would highlight the next, previous, or all instances of the given selection.

	\subsection{Replace}
	\keys{\Alt + R}
	Replaces a selection. Input is whatever the user wants to replace the selection with.

	\subsection{Replace similar selections}
	\keys{\Alt + R + S}
	Replaces next, previous, or all similar selections. Input ranges from: "next", "previous", and "all". This command would replace the next, previous, or all instances of the given selection.

\section{Text entry and manipulation}

	\subsection{Text entry}
	\begin{enumerate}
	\item \keys{\Alt + R}
	Records user input. This would allow the user to record any text they want to have entered. Keywords of whatever syntax the file is in would be recognized. Certain keywords would denote operators like +, =, |, /, etc. This command would also take car of declaring a new variable. A user's preferences and the syntax of the file that the user is working on shape the way that variables would be declared. For example, a user could define the standard to be camel casing, or underscores between words, or hyphens. This preference could be assigned by language or just generally by the user. Depending on the language variable types definitely apply.

	\item \keys{\Alt + R + V}
	Records verbatim. This would tell the application to ignore keywords and to simply record whatever input the user has provided. This would allow for saying input like "for", "equals", "pipe", etc. so that the application would not be confused with what to enter into the file.
	\end{enumerate}

	\subsubsection{Deleting Text}
	\keys{\Alt + D}
	Delete a certain part of the text. This works extremely similarly to text selection. All of the same inputs work in the same way except for that the simply delete the text instead of selecting it. An added input here would be "delete" for the case that the user has selected some text and then decides to delete it after the selection was made.


\section{Window/view manipulation}

	\keys{\Alt + W}
	Changes the view of the current file. Input includes: "up", "down", "page up", "page down" "top", and "bottom". This command would also allow for an input of "minimize" to minimize a window. User inputs of "left" and "right" would cycle through the active tabs of the window in the direction that was specified.

\section{\menu{Tools}}

	\begin{enumerate}
	\item \keys{\Alt + B}
	Builds the file with whatever system is currently chosen. User input is: "build".

	\item \keys{\Alt + B + S}
	Changes the build system to the users input. Examples include: "Python", "Make", "C++", "\LaTeX", etc.
	\end{enumerate}

\subsection{Preferences}
	\keys{\Alt + P}
	Changes a preference. Input for this can be: "font" and  "color scheme". "font" can be suffixed with "larger" and "smaller". This command would not be able to edit and package control settings due to the way \textbf{Sublime Text} stores preference files. 

\section{User defined commands}


\section{\menu{Other}}

	\subsection{File syntax}
	\keys{\Alt + S + Y}
	Changes the syntax of the file. Sample input of the user includes: "Python", "C++", "\LaTeX", "Ruby on Rails", "JSON", etc.

	\subsection{File encoding}
	\keys{\Alt + E}
	Changes the encoding of the file. Input from the user can be: "UTF-8", "UTF-16 Little Endian", etc.

	\subsection{Go to line number}
	\keys{\Alt + L}
	Moves the cursor to a certain line number. Sample input can include a specific line number or the top or bottom. Examples: "fifty-three", "first", "last", "two", etc. These inputs can prefixed with "end of" and "beginning of" to go to the end or beginning of that line. The default will be the beginning of the line. This could be changed in the user preferences.


\section{Usage Scenarios}

\subsection{Handicapped persons}

The first user group that comes to mind are people who normally have some difficulty typing. Due to some physical barriers, they might be unable to input or manipulate text via the keyboard. This application would allow for the people who want to code to be able to do so. 

\subsection{The tired coder}

The second user group that comes to mind is the coder who is simply just tired of typing. For this target group, the technology would simply be an addition to their flow of programming. For example, when a user wants to move a piece of code into another function, this application would perform the given task faster than the typing equivalent. The action required for this is as follows: \keys{\Alt + M} "move into function XXX". This involves less keystrokes and scrolling than the normal action: \keys{\cmd + X}, then some scrolling, then \keys{\cmd + V}.




\section{Rationale}

\subsection{Priorities}

\subsection{Mental Models}

\subsection{Interaction design concepts, guidelines, principles, and theories}




\section{Usability metric forecast}

\subsection{Learnability}
The overall learnability of the application would not be the fastest. Learning a new set of key commands is never a quick thing to lean. Also learning new phrases for certain actions for users could take a while. Since the user would be guided through a series of tasks the very first time they opened the application, this would help with the learnability. This help sequence would be available for the user to reacquaint themselves at any time with the applications commands.

\subsection{Efficiency}
The efficiency of the application would increase over time. As a user became more and more familiar with the flow of the application, they would be able to use the application very efficiently. Since the list of actions is fairly comprehensive, the actions that a user could accomplish via voice is nearly the same as via keyboard.

\subsection{Errors}
The rate of errors would decrease over time. But as imagined, they could be pretty high for a first time user. In any case, the user would be able to simply ue the keyboard to accomplish their task instead of using the voice control.

\subsection{Memorability}
In terms of memorability, the application would fare well. The same commands would do that same things and revisiting this application after some time would not take long to remember how the application functions. Re-familiarizing oneself with the application would be straightforward. Once again, a user could look to the series of tasks outlined in the help section to reacquaint themselves with the application.

\subsection{Satisfaction}
Not surprisingly, this metric is largely subjective. For people who previously had a hard time coding due to a disability, this would induce large amounts of satisfaction. For people who do not have any physical disabilities impeding them from typing, their satisfaction would rely upon how efficient they have become at using the application. The overall learning process could be slightly hard, therefore unsatisfactory.

\pagebreak


\section{Key command table}


\begin{tabular}{ | l | l | l |}
\hline
Key command & Voice input & corresponding menu action \\ \hline
\multirow{2}{*}{\keys{\Alt + Y}} & "save"  & \menu{File > Save}\\
	& "save as" & \menu{File > Save As..}\\ \hline
\keys{\Alt + E} & & \\ \hline
\keys{\Alt + Z} & & \\ \hline
\keys{\Alt + S} & & \\ \hline
\keys{\Alt + S + M} & & \\ \hline
\keys{\Alt + M} & & \\ \hline
\keys{\Alt + T} & & \\ \hline
\keys{\Alt + F} & & \\ \hline
\keys{\Alt + F + S} & & \\ \hline
\keys{\Alt + R} & & \\ \hline
\keys{\Alt + R + S} & & \\ \hline
\keys{\Alt + R} & & \\ \hline
\keys{\Alt + R + V} & & \\ \hline
\keys{\Alt + D} & & \\ \hline
\keys{\Alt + W} & & \\ \hline
\keys{\Alt + B} & & \\ \hline
\keys{\Alt + B + S} & & \\ \hline
\keys{\Alt + P} & & \\ \hline
\keys{\Alt + S + Y} & & \\ \hline
\keys{\Alt + E} & & \\ \hline
\keys{\Alt + L} & & \\ \hline
\end{tabular}

\end{document}
	